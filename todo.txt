Remove the CodePointer attribute. Or move CodePointer to the same file.
Error messages for bad arguments.
Implement separated lists.
The quantifiers should be called quantifiers, not non terminals
Nonterminal is one word, not two.
var maybeInstruction = interpreter[name](cp) -> 
var e = new TypeError("TypeError: "+name+" is not an interpreter method");
if(!(interpreter[methodName] instanceof Function)) {
  throw e;
}
var mi = interpreter[name](cp);
return mi;
Move CodePointer method tests to specInterpreterCodePointer.js, except parse

token.toString() -> token.toString().replace(/^\/\^?/, "/^")
  
Make better error message for InterpreterMethodFactory.prototype
  .makeMethod(function(){return null;});
  current is Expected /^undefined/ to match '[object Object]'.
  No, this ocurres when a nonterminal fails before codePointer.parse has been
  called. Testable by writing a new interpreter method factory method that 
  fails, but I think this is a failure of Semantics! itself, not a bug in 
  the input to the interpreter. Maybe should be reported as an extention 
  failure?
Detect if recursive call is necessary by resetting and setting a boolean in 
  head.
Move the static methods of InterpreterMethodFactory into a closure
Write test case for debugging when the top symbol has a copied twin method.
Add ^ to match debugging message to emphazise that it is a head match.
Make debugging report the captured groups of a match
Allow another this-binding than the interpreter itself.
Add exeptions to InterpreterMethodFactory.callInterpreterMethod
Put object result construction in group in its own method.
Move methodMaker from the prototype/this so that the factory methods can be 
  called as functions, e g apply
Make a method accept many strings, concatenate them.
The nonterminal padding behaves like group, but it returns the result of the 
  first named non regex method instead of an object. Optional index returns 
  the result of a later method instead.
Put code pointer match in quotation marks in debugging messages.
Implement but not in atoms. A pattern that the full match should not match, 
  treated as parse failure. May also be a list of strings, which is easier to 
  handle and more dynamic.
Remove capturing groups as a feature in atoms. Only the full match is supplied. 
Deferred methods should provide the this-binding themself, not explicitly. 
  Might be use cases for both scenarios. Make it optional defaulting to bind. 
  Or just thisBinding = this||interpreter;
Deffered methods should accept parameters, which will be supplied as 
  additional arguments to the interpretation.
baaa => bas in head recursion tests.
Remove repetition in error message of 
  i.a = atom(/a/);
  i.aa = or("a", "a");
  i.aa("b");
What is the error message of i.e("a")?
