<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: spec/system/src/JavaScriptInterpreter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: spec/system/src/JavaScriptInterpreter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Returns a newly constructed JavaScript interpreter. 
 * @class
 * @classdesc &lt;p>
 * This class is a real world example of how an 
 * {@link InterpreterMethodFactory} can be used to make a fully functional 
 * interpreter. 
 * It is an interpreter for a subset of the JavaScript language, just large 
 * enough to interpret the source code of {@link InterpreterMethodFactory.js}. 
 * &lt;/p>&lt;p>
 * It is a fully functional interpreter. 
 * It is possible to run all unit tests of Semantics! on this interpretation, 
 * and all the tests for this {@link UsageExampleJavaScriptInterpreter} 
 * can be run on this class being constructed with that interpretation. 
 * &lt;/p>
 * @alias UsageExampleJavaScriptInterpreter
 */
function JavaScriptInterpreter() {
  
}

JavaScriptInterpreter.hack = function() {
  var interpreterMethodFactory = new InterpreterMethodFactory();
  var identifierName = /[a-zA-Z_\$][a-zA-Z0-9_\$]*/;
  
  // Lexical Grammar
  /**
   * &lt;tt>{@link InterpreterMethodFactory#star|star} ("space")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.spaces = 
  interpreterMethodFactory.star("space", function(spaces) {
    return spaces.join("");
  });

  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("whiteSpace", 
   * "lineTerminator", "singleLineComment", "multiLineComment")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.space = 
  interpreterMethodFactory.or("whiteSpace", "lineTerminator", 
  "singleLineComment", "multiLineComment");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/\s/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.whiteSpace = 
  interpreterMethodFactory.terminal(/\s/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/\n/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.lineTerminator = 
  interpreterMethodFactory.terminal(/\n/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} 
   * (/\/\/.*&lt;/tt>&lt;tt>/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.singleLineComment = 
  interpreterMethodFactory.terminal(/\/\/.*/);

  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} 
   * (/\/\*\/*(\**[^\*\/]+\/*)*\*+\//)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.multiLineComment = 
  interpreterMethodFactory.terminal(/\/\*\/*(\**[^\*\/]+\/*)*\*+\//);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} 
   * (identifierName)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.identifierName = 
  interpreterMethodFactory.terminal(identifierName);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("undefinedLiteral", 
   * "nullLiteral", "booleanLiteral", "numericLiteral", "stringLiteral", 
   * "regularExpressionLiteral")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.literal = 
  interpreterMethodFactory.or("undefinedLiteral", "nullLiteral", 
  "booleanLiteral", "numericLiteral", "stringLiteral", 
  "regularExpressionLiteral");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/undefined/, 
   * function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.undefinedLiteral = 
  interpreterMethodFactory.terminal(/undefined/, function() {
    return undefined;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/null/, function() 
   * {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.nullLiteral = 
  interpreterMethodFactory.terminal(/null/, function() {return null;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("trueLiteral", 
   * "falseLiteral")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.booleanLiteral = 
  interpreterMethodFactory.or("trueLiteral", "falseLiteral");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/true/, function() 
   * {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.trueLiteral = 
  interpreterMethodFactory.terminal(/true/, function() {return true;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/false/, 
   * function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.falseLiteral = 
  interpreterMethodFactory.terminal(/false/, function() {return false;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/\d+/, 
   * function(numericLiteral) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.numericLiteral = 
  interpreterMethodFactory.terminal(/\d+/, function(numericLiteral) {
    return Number(numericLiteral);
  });
  
  /**
   * &lt;tt>insignificant("stringLiteralSignificantSpaces", null)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.stringLiteral = 
  interpreterMethodFactory.
  insignificant("stringLiteralSignificantSpaces", null);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or}
   * ("stringLiteralSignificantSpaces1", 
   * "stringLiteralSignificantSpaces2")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.stringLiteralSignificantSpaces = 
  interpreterMethodFactory.or("stringLiteralSignificantSpaces1", 
  "stringLiteralSignificantSpaces2");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/"/, 
   * "doubleStringCharacters", /"/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.stringLiteralSignificantSpaces1 = 
  interpreterMethodFactory.wrap(/"/, "doubleStringCharacters", /"/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/'/, 
   * "singleStringCharacters", /'/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.stringLiteralSignificantSpaces2 = 
  interpreterMethodFactory.wrap(/'/, "singleStringCharacters", /'/);
  
  var unescape = function(s) {
    s = s.replace(/\\['"\\bfnrtv]/g, function(match) {
      return characterEscapeSequence[match];
    });
    
    return s;
  };
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal}
   * (/([^"\\]|(\\.))*&lt;/tt>&lt;tt>/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.doubleStringCharacters = 
  interpreterMethodFactory.terminal(/([^"\\]|(\\.))*/, unescape);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal}
   * (/([^'\\]|(\\.))*&lt;/tt>&lt;tt>/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.singleStringCharacters = 
  interpreterMethodFactory.terminal(/([^'\\]|(\\.))*/, unescape);
  
  var characterEscapeSequence = {
    "\\\'": "\'",
    "\\\"": "\"",
    "\\\\": "\\",
    "\\b": "\b", 
    "\\f": "\f", 
    "\\n": "\n", 
    "\\r": "\r", 
    "\\t": "\t",
    "\\v": "\v",
  };
  
  /**
   * &lt;tt>insignificant("regularExpressionLiteralSignificantSpaces, null")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.regularExpressionLiteral = 
  interpreterMethodFactory.
  insignificant("regularExpressionLiteralSignificantSpaces", null);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\//, 
   * "regularExpressionBody", /\//)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.regularExpressionLiteralSignificantSpaces = 
  interpreterMethodFactory.wrap(/\//, "regularExpressionBody", /\//);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal}
   * (/([^/\\\[]|(\\.)|(\[([^\]\\]|(\\.))*\]))+/, 
   * function(regularExpressionBody) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.regularExpressionBody = 
  interpreterMethodFactory.terminal(/([^/\\\[]|(\\.)|(\[([^\]\\]|(\\.))*\]))+/, 
  function(regularExpressionBody) {
    return new RegExp(regularExpressionBody);
  });
  
  // Expressions
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} ("bindingIdentifier", 
   * function(bindingIdentifier) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.identifierReference = 
  interpreterMethodFactory.wrap("bindingIdentifier", 
  function(bindingIdentifier) {
    var base = this.executionContext;
    while(!base.variables.hasOwnProperty(bindingIdentifier)) {
      base = base.outer;
      if(!base) {
        throw new ReferenceError(bindingIdentifier + " is not defined");
      }
    }
    
    return {
      base: base.variables,
      name: bindingIdentifier,
    };
    
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} ("identifierReference", 
   * function(identifierReference) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.identifierExpression = 
  interpreterMethodFactory.wrap("identifierReference", 
  function(identifierReference) {
    return identifierReference.base[identifierReference.name];
  });
  
  var reservedWord = ["break", "case", "catch", "class", "continue", 
  "debugger", "default", "delete", "do", "else", "enum", "export", "extends", 
  "false", "finally", "for", "function", "if", "implements", "import", "in", 
  "instanceof", "let", "new", "null", "package", "private", "protected", 
  "public", "return", "static", "super", "switch", "this", "throw", "true", 
  "try", "typeof", "undefined", "var", "void", "while", "with", "yield"];
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (identifierName, 
   * reservedWord)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.bindingIdentifier = 
  interpreterMethodFactory.butNot("identifierName", reservedWord);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("literal", 
   * "objectExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.primaryExpression = 
  interpreterMethodFactory.or("literal", "objectExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("identifierExpression", 
   * "arrayLiteral", "objectLiteral", 
   * "functionExpression", "objectExpression1", "thisExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.objectExpression = 
  interpreterMethodFactory.or("identifierExpression", "arrayLiteral", 
  "objectLiteral", "functionExpression", "objectExpression1", 
  "thisExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\(/, "expression", 
   * /\)/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.objectExpression1 = 
  interpreterMethodFactory.wrap(/\(/, "expression", /\)/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#terminal|terminal} (/this/, function() 
   * {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.thisExpression = 
  interpreterMethodFactory.terminal(/this/, function() {
    return this.executionContext.thisBinding;
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\[/, "elementList", 
   * /\]/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.arrayLiteral = 
  interpreterMethodFactory.wrap(/\[/, "elementList", /\]/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#star|star} ("assignmentExpression", 
   * /,/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.elementList = 
  interpreterMethodFactory.star("assignmentExpression", /,/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/\{/, 
   * "propertyNameAndValueList", /,?/, /\}/, function(propertyNameAndValueList) 
   * {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.objectLiteral = 
  interpreterMethodFactory.group(/\{/, "propertyNameAndValueList", /,?/, /\}/, 
  function(propertyNameAndValueList) {
    var result = {};
    propertyNameAndValueList.map(function(propertyAssignment) {
      result[propertyAssignment.propertyName] = 
          propertyAssignment.assignmentExpression;
    });
    
    return result;
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#star|star} ("propertyAssignment", 
   * /,/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.propertyNameAndValueList = 
  interpreterMethodFactory.star("propertyAssignment", /,/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("propertyName", /:/, 
   * "assignmentExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.propertyAssignment = 
  interpreterMethodFactory.group("propertyName", /:/, "assignmentExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("identifierName")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.propertyName = 
  interpreterMethodFactory.or("identifierName");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("newExpression1", 
   * "primaryExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.newExpression = 
  interpreterMethodFactory.or("newExpression1", "primaryExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/new/, 
   * "newExpressionQualifier", "argumentsOpt", function(newExpressionQualifier, 
   * argumentsOpt) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.newExpression1 = 
  interpreterMethodFactory.group(/new/, "newExpressionQualifier", 
  "argumentsOpt", function(newExpressionQualifier, argumentsOpt) {
    var object = Object.create(newExpressionQualifier.prototype);
    var result = newExpressionQualifier.apply(object, argumentsOpt);
    return result&amp;&amp;typeof result==="object"?result:object;
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#longest|longest} ("newExpression", 
   * "newExpressionQualifier1")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.newExpressionQualifier = 
  interpreterMethodFactory.longest("newExpression", "newExpressionQualifier1");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} 
   * ("newExpressionQualifier", "qualifier", 
   * function(newExpressionQualifier, qualifier) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.newExpressionQualifier1 = 
  interpreterMethodFactory.group("newExpressionQualifier", "qualifier",
  function(newExpressionQualifier, qualifier) {
    return newExpressionQualifier[qualifier];
  });
  
  /**
   * &lt;tt>or("args", function(){...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.argumentsOpt = 
  interpreterMethodFactory.or("args", function(){
    return [];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("callExpression1", 
   * "callExpression2", "newExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.callExpression = 
  interpreterMethodFactory.or("callExpression1", "callExpression2", 
  "newExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("callExpression", 
   * "args", function(callExpression, args) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.callExpression1 = 
  interpreterMethodFactory.group("callExpression", "args", 
  function(callExpression, args) {
    return callExpression.apply(undefined, args);
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} 
   * ("callExpressionQualifier", "args", function(callExpressionQualifier, 
   * args) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.callExpression2 = 
  interpreterMethodFactory.group("callExpressionQualifier", "args", 
  function(callExpressionQualifier, args) {
    return callExpressionQualifier.value.
    apply(callExpressionQualifier.base, args);
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#longest|longest}
   * ("callExpressionQualifier1", "callExpressionQualifier2")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.callExpressionQualifier = 
  interpreterMethodFactory.longest("callExpressionQualifier1", 
  "callExpressionQualifier2");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("callExpression", 
   * "qualifier", function(callExpression, qualifier) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.callExpressionQualifier1 = 
  interpreterMethodFactory.group("callExpression", "qualifier", 
  function(callExpression, qualifier) {
    return {
      base: callExpression,
      value: callExpression[qualifier],
    };
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} 
   * ("callExpressionQualifier", "qualifier", function(callExpressionQualifier, 
   * qualifier) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.callExpressionQualifier2 = 
  interpreterMethodFactory.group("callExpressionQualifier", "qualifier", 
  function(callExpressionQualifier, qualifier) {
    return {
      base: callExpressionQualifier.value,
      value: callExpressionQualifier.value[qualifier],
    };
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("qualifier1", 
   * "qualifier2")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.qualifier = 
  interpreterMethodFactory.or("qualifier1", "qualifier2");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\[/, "expression", 
   * /\]/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.qualifier1 = 
  interpreterMethodFactory.wrap(/\[/, "expression", /\]/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\./, 
   * "identifierName")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.qualifier2 = 
  interpreterMethodFactory.wrap(/\./, "identifierName");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\(/, "argumentList", 
   * 
   * /\)/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.args = 
  interpreterMethodFactory.wrap(/\(/, "argumentList", /\)/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#star|star} ("assignmentExpression", 
   * /,/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.argumentList = 
  interpreterMethodFactory.star("assignmentExpression", /,/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("leftHandSideExpression1", 
   * "leftHandSideExpression2", 
   * "identifierReference")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.leftHandSideExpression = 
  interpreterMethodFactory.or("leftHandSideExpression1", 
  "leftHandSideExpression2", "identifierReference");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} 
   * ("leftHandSideExpression", "qualifier", 
   * function(leftHandSideExpression, qualifier) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.leftHandSideExpression1 = 
  interpreterMethodFactory.group("leftHandSideExpression", "qualifier", 
  function(leftHandSideExpression, qualifier) {
    return {
      base: leftHandSideExpression.base[leftHandSideExpression.name],
      name: qualifier,
    };
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("callExpression", 
   * "qualifier", function(leftHandSideExpressionBase, qualifier) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.leftHandSideExpression2 = 
  interpreterMethodFactory.group("callExpression", "qualifier", 
  function(leftHandSideExpressionBase, qualifier) {
    return {
      base: leftHandSideExpressionBase,
      name: qualifier,
    };
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#longest|longest} ("updateExpression1", 
   * "updateExpression2", "updateExpression3", "callExpression", 
   * "rightHandSideExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.updateExpression = 
  interpreterMethodFactory.longest("updateExpression1", "updateExpression2", 
  "updateExpression3", "callExpression", "rightHandSideExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/delete/, 
   * "leftHandSideExpression", function(lhse) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.updateExpression1 = 
  interpreterMethodFactory.wrap(/delete/, "leftHandSideExpression",  
  function(lhse) {return delete lhse.base[lhse.name];});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} ("leftHandSideExpression", 
   * /\+\+/, function(lhse) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.updateExpression2 = 
  interpreterMethodFactory.wrap("leftHandSideExpression", /\+\+/, 
  function(lhse) {return lhse.base[lhse.name]++;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} ("leftHandSideExpression", 
   * /--/, function(lhse) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.updateExpression3 = 
  interpreterMethodFactory.wrap("leftHandSideExpression", /--/, 
  function(lhse) {return lhse.base[lhse.name]--;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap}
   * ("leftHandSideExpression", function(lhse) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.rightHandSideExpression = 
  interpreterMethodFactory.wrap("leftHandSideExpression", 
  function(leftHandSideExpression) {
    return leftHandSideExpression.base[leftHandSideExpression.name];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("updateExpression", 
   * "typeChangeExpression2", "typeChangeExpression4", 
   * "typeChangeExpression6")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.typeChangeExpression = 
  interpreterMethodFactory.or("updateExpression", "typeChangeExpression2", 
  "typeChangeExpression4", "typeChangeExpression6");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/typeof/, 
   * "typeChangeExpression", function(typeChangeExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.typeChangeExpression2 = 
  interpreterMethodFactory.group(/typeof/, "typeChangeExpression", 
  function(typeChangeExpression) {return typeof typeChangeExpression;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/-/, 
   * "typeChangeExpression", function(typeChangeExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.typeChangeExpression4 = 
  interpreterMethodFactory.group(/-/, "typeChangeExpression", 
  function(typeChangeExpression) {return -typeChangeExpression;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/!/, 
   * "typeChangeExpression", function(typeChangeExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.typeChangeExpression6 = 
  interpreterMethodFactory.group(/!/, "typeChangeExpression", 
  function(typeChangeExpression) {return !typeChangeExpression;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("multiplicativeExpression1", 
   * "typeChangeExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.multiplicativeExpression = 
  interpreterMethodFactory.or("multiplicativeExpression1", 
  "typeChangeExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group}
   * ("multiplicativeExpression", /\*&lt;/tt>&lt;tt>/, "typeChangeExpression", 
   * function(me, tce) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.multiplicativeExpression1 = 
  interpreterMethodFactory.group("multiplicativeExpression", /\*/, 
  "typeChangeExpression", function(me, tce) {return me*tce;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("additiveExpression1", 
   * "additiveExpression2", "multiplicativeExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.additiveExpression = 
  interpreterMethodFactory.or("additiveExpression1", "additiveExpression2", 
  "multiplicativeExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("additiveExpression", 
   * /\+/, "multiplicativeExpression", function(ae, me) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.additiveExpression1 = 
  interpreterMethodFactory.group("additiveExpression", /\+/, 
  "multiplicativeExpression", function(ae, me) {return ae+me;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("additiveExpression", 
   * /-/, "multiplicativeExpression", function(ae, me) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.additiveExpression2 = 
  interpreterMethodFactory.group("additiveExpression", /-/, 
  "multiplicativeExpression", function(ae, me) {return ae-me;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("relationalExpression1", 
   * "relationalExpression2", "relationalExpression5", 
   * "additiveExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.relationalExpression = 
  interpreterMethodFactory.or("relationalExpression1", "relationalExpression2", 
  "relationalExpression5", "additiveExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("relationalExpression", 
   * /&lt;/, "additiveExpression", function(re, ae) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.relationalExpression1 = 
  interpreterMethodFactory.group("relationalExpression", /&lt;/, 
  "additiveExpression", function(re, ae) {return re&lt;ae;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("relationalExpression", 
   * />/, "additiveExpression", function(re, ae) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.relationalExpression2 = 
  interpreterMethodFactory.group("relationalExpression", />/, 
  "additiveExpression", function(re, ae) {return re>ae;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("relationalExpression", 
   * /instanceof/, "additiveExpression", function(re, ae) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.relationalExpression5 = 
  interpreterMethodFactory.group("relationalExpression", /instanceof/, 
  "additiveExpression", function(re, ae) {return re instanceof ae;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("equalityExpression3", 
   * "equalityExpression4", "relationalExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.equalityExpression = 
  interpreterMethodFactory.or("equalityExpression3", "equalityExpression4", 
  "relationalExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("equalityExpression", 
   * /===/, "relationalExpression", function(ee, re) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.equalityExpression3 = 
  interpreterMethodFactory.group("equalityExpression", /===/, 
  "relationalExpression", function(ee, re) {return ee===re;});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("equalityExpression", 
   * /!==/, "relationalExpression", function(ee, re) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.equalityExpression4 = 
  interpreterMethodFactory.group("equalityExpression", /!==/, 
  "relationalExpression", function(ee, re) {return ee!==re;});
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("logicalAndExpression1", 
   * "equalityExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.logicalAndExpression = 
  interpreterMethodFactory.or("logicalAndExpression1", "equalityExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("logicalAndExpression", 
   * /&amp;&amp;/, "deferredEqualityExpression", function(logicalAndExpression, 
   * deferredEqualityExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.logicalAndExpression1 = 
  interpreterMethodFactory.group("logicalAndExpression", /&amp;&amp;/, 
  "deferredEqualityExpression", 
  function(logicalAndExpression, deferredEqualityExpression) {
    return logicalAndExpression &amp;&amp; deferredEqualityExpression.call(this);
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("equalityExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredEqualityExpression = 
  interpreterMethodFactory.methodFactory("equalityExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("logicalOrExpression1", 
   * "logicalAndExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.logicalOrExpression = 
  interpreterMethodFactory.or("logicalOrExpression1", "logicalAndExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("logicalOrExpression", 
   * /\|\|/, "deferredLogicalAndExpression", function(logicalOrExpression, 
   * deferredLogicalAndExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.logicalOrExpression1 = 
  interpreterMethodFactory.group("logicalOrExpression", /\|\|/, 
  "deferredLogicalAndExpression", function(logicalOrExpression, 
  deferredLogicalAndExpression) {
    return logicalOrExpression||deferredLogicalAndExpression.call(this);
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("logicalAndExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredLogicalAndExpression = 
  interpreterMethodFactory.methodFactory("logicalAndExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("conditionalExpression1", 
   * "logicalOrExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.conditionalExpression = 
  interpreterMethodFactory.or("conditionalExpression1", "logicalOrExpression");
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("logicalOrExpression", 
   * /\?/, "deferredAssignmentExpression", 
   * /:/, "deferredAssignmentExpression", function(logicalOrExpression, 
   * deferredAssignmentExpression1, deferredAssignmentExpression2) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.conditionalExpression1 = 
  interpreterMethodFactory.group("logicalOrExpression", /\?/, 
  "deferredAssignmentExpression", /:/, "deferredAssignmentExpression", 
  function(logicalOrExpression, deferredAssignmentExpression1, 
  deferredAssignmentExpression2) {
    return logicalOrExpression?
      deferredAssignmentExpression1.call(this):
      deferredAssignmentExpression2.call(this);
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("assignmentExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredAssignmentExpression = 
  interpreterMethodFactory.methodFactory("assignmentExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("assignmentExpression1", 
   * "assignmentExpression5", "conditionalExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.assignmentExpression = 
  interpreterMethodFactory.or("assignmentExpression1", "assignmentExpression5", 
  "conditionalExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ( 
   * "leftHandSideExpression", /=/, "assignmentExpression", 
   * function(lhse, assignmentExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.assignmentExpression1 = 
  interpreterMethodFactory.group("leftHandSideExpression", /=/, 
  "assignmentExpression", function(lhse, assignmentExpression) {
    return (lhse.base[lhse.name] = assignmentExpression);});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (
   * "leftHandSideExpression", /\+=/, "assignmentExpression", 
   * function(lhse, assignmentExpression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.assignmentExpression5 = 
  interpreterMethodFactory.group("leftHandSideExpression", /\+=/, 
  "assignmentExpression", function(lhse, assignmentExpression) {
    return (lhse.base[lhse.name] += assignmentExpression);});
  
  /**
   * &lt;tt>plus("assignmentExpression", /,/, function(assignmentsExpressions) 
   * {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.expression = 
  interpreterMethodFactory.plus("assignmentExpression", /,/, 
  function(assignmentsExpressions) {
    return assignmentsExpressions[assignmentsExpressions.length-1];
  });
  
  // Statements
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("block", "variableStatement", 
   * "ifStatement", "iterationStatement", "returnStatement", "throwStatement", 
   * "functionDeclaration", "expressionStatement")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.statement = 
  interpreterMethodFactory.or("block", "variableStatement", "ifStatement", 
  "iterationStatement", "returnStatement", "throwStatement", 
  "functionDeclaration", "expressionStatement");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("statement")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredStatement = 
  interpreterMethodFactory.methodFactory("statement");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/\{/, "statementList", 
   * /\}/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.block = 
  interpreterMethodFactory.wrap(/\{/, "statementList", /\}/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#star|star} ("deferredStatement", 
   * function(deferredStatements) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.statementList = 
  interpreterMethodFactory.star("deferredStatement", 
  function(deferredStatements) {
    for(var i = 0; i &lt; deferredStatements.length; i++) {
      var returnValue = deferredStatements[i].call(this);
      if(returnValue[0] === "return") {
        return returnValue;
      }
    }
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("statementList")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredStatementList = 
  interpreterMethodFactory.methodFactory("statementList");

  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/var/, 
   * "variableDeclarationList", /;/, function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.variableStatement = 
  interpreterMethodFactory.group(/var/, "variableDeclarationList", /;/, 
  function() {
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>plus("variableDeclaration", /,/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.variableDeclarationList = 
  interpreterMethodFactory.plus("variableDeclaration", /,/);
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("bindingIdentifier", 
   * "initialiserOpt", function(bindingIdentifier, initialiserOpt) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.variableDeclaration = 
  interpreterMethodFactory.group("bindingIdentifier", 
  "initialiserOpt", function(bindingIdentifier, initialiserOpt) {
    this.executionContext.variables[bindingIdentifier] = initialiserOpt;
    return bindingIdentifier;
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/=/, 
   * "assignmentExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.initialiser = 
  interpreterMethodFactory.wrap(/=/, "assignmentExpression");
  
  /**
   * &lt;tt>or("initialiser", function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.initialiserOpt = 
  interpreterMethodFactory.or("initialiser", function() {
    return undefined;
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} ("expression", /;/, 
   * function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.expressionStatement = 
  interpreterMethodFactory.group("expression", /;/, function() {
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} 
   * (/if/, /\(/, "expression", /\)/, "deferredStatement", 
   * "deferredElseStatementOpt", function(expression, deferredStatement, 
   * deferredElseStatementOpt) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.ifStatement = 
  interpreterMethodFactory.group(/if/, /\(/, "expression", /\)/, 
  "deferredStatement", "deferredElseStatementOpt", 
  function(expression, deferredStatement, deferredElseStatementOpt) {
    if(expression) {
      return deferredStatement.call(this);
    } else {
      return deferredElseStatementOpt.call(this);
    }
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("expression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredExpression = 
  interpreterMethodFactory.methodFactory("expression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("iterationStatement2", 
   * "iterationStatement4", "iterationStatement6")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.iterationStatement = 
  interpreterMethodFactory.or("iterationStatement2", "iterationStatement4", 
  "iterationStatement6");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/while/, /\(/, 
   * "deferredExpression", /\)/, "deferredStatement", 
   * function(deferredExpression, deferredStatement) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.iterationStatement2 = 
  interpreterMethodFactory.group(/while/, /\(/, "deferredExpression", /\)/, 
  "deferredStatement", 
  function(deferredExpression, deferredStatement) {
    while(deferredExpression.call(this)) {
      var returnValue = deferredStatement.call(this);
      if(returnValue[0] === "return") {
        return returnValue;
      }
    }
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/for/, /\(/, /var/, 
   * "variableDeclarationList", /;/, "deferredExpression", /;/, 
   * "deferredExpression", /\)/, "deferredStatement", 
   * function(variableDeclarationList, deferredExpression1, 
   * deferredExpression2, deferredStatement) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.iterationStatement4 = 
  interpreterMethodFactory.group(/for/, /\(/, /var/, "variableDeclarationList", 
  /;/, "deferredExpression", /;/, "deferredExpression", /\)/, 
  "deferredStatement", 
  function(variableDeclarationList, deferredExpression1, deferredExpression2, 
  deferredStatement) {
    for( ; deferredExpression1.call(this); deferredExpression2.call(this)){
      var returnValue = deferredStatement.call(this);
      if(returnValue[0] === "return") {
        return returnValue;
      }
    }
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/for/, /\(/, /var/, 
   * "variableDeclaration", /in/, "expression", 
   * /\)/, "deferredStatement", function(variableDeclaration, 
   * expression, deferredStatement) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.iterationStatement6 = 
  interpreterMethodFactory.group(/for/, /\(/, /var/, "variableDeclaration", 
  /in/, "expression", /\)/, "deferredStatement", 
  function(variableDeclaration, expression, deferredStatement) {
    for(var propertyName in expression) {
      this.executionContext.variables[variableDeclaration] = propertyName;
      var returnValue = deferredStatement.call(this);
      if(returnValue[0] === "return") {
        return returnValue;
      }
    }
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("elseStatementOpt")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredElseStatementOpt = 
  interpreterMethodFactory.methodFactory("elseStatementOpt");
  
  /**
   * &lt;tt>or("elseStatement", function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.elseStatementOpt = 
  interpreterMethodFactory.or("elseStatement", 
  function() {
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/else/, 
   * "statement")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.elseStatement = 
  interpreterMethodFactory.wrap(/else/, "statement");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/return/, 
   * "expression", /;/, function(expression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.returnStatement = 
  interpreterMethodFactory.group(/return/, "expression", /;/, 
  function(expression) {
    return ["return", expression];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/throw/, 
   * "expression", /;/, function(expression) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.throwStatement = 
  interpreterMethodFactory.group(/throw/, "expression", /;/, 
  function(expression) {
    throw expression;
  });
  
  // Functions and programs
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap}
   * ("namedFunctionExpression", function() {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.functionDeclaration = 
  interpreterMethodFactory.wrap("namedFunctionExpression", function() {
    return ["normal", undefined];
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("anonymousFunctionExpression", 
   * "namedFunctionExpression")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.functionExpression = 
  interpreterMethodFactory.or("anonymousFunctionExpression",
  "namedFunctionExpression");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/function/, 
   * "bindingIdentifier", "functionExpressionContent", 
   * function(bindingIdentifier, functionExpressionContent) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.namedFunctionExpression = 
  interpreterMethodFactory.group(/function/, "bindingIdentifier", 
  "functionExpressionContent", 
  function(bindingIdentifier, functionExpressionContent) {
    this.executionContext.variables[bindingIdentifier] = 
        functionExpressionContent;
    return functionExpressionContent;
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#wrap|wrap} (/function/, 
   * "functionExpressionContent")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.anonymousFunctionExpression = 
  interpreterMethodFactory.wrap(/function/, "functionExpressionContent");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group} (/\(/, 
   * "formalParameterList", /\)/, /\{/, "functionBody", /\}/, 
   * function(formalParameterList, functionBody) {...})&lt;/tt>
   */
  JavaScriptInterpreter.prototype.functionExpressionContent = 
  interpreterMethodFactory.group(/\(/, "formalParameterList", /\)/, 
  /\{/, "functionBody", /\}/, function(formalParameterList, functionBody) {
    var that = this;
    var outerExecutionContext = this.executionContext;
    return function() {
      var stack = that.executionContext;
      args = {};
      for(var i = 0; i &lt; formalParameterList.length; i++) {
        args[formalParameterList[i]] = arguments[i];
      }
      args["arguments"] = arguments;
      that.executionContext = {
        outer: outerExecutionContext,
        variables: args,
        thisBinding: this,
      };
      
      var result = functionBody.call(that);
      that.executionContext = stack;
      return result[1];
    };
  });
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#star|star} ("bindingIdentifier", 
   * /,/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.formalParameterList = 
  interpreterMethodFactory.star("bindingIdentifier", /,/);
  
  /**
   * &lt;tt>select(2, "useStrictDeclarationOpt", "deferredSourceElements")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.functionBody = 
  interpreterMethodFactory.select(2, "useStrictDeclarationOpt", 
  "deferredSourceElements");
  
  /**
   * &lt;tt>or("useStrictDeclaration")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.useStrictDeclarationOpt = 
  interpreterMethodFactory.or("useStrictDeclaration", function() {});
  /**
   * &lt;tt>{@link InterpreterMethodFactory#group|group}
   * (/('use strict')|("use strict")/, /;/)&lt;/tt>
   */
  JavaScriptInterpreter.prototype.useStrictDeclaration = 
  interpreterMethodFactory.group(/('use strict')|("use strict")/, /;/);
  
  /**
   * Setting up the environment and calling program1.
   */
  JavaScriptInterpreter.prototype.program = 
  function(code, globalOrDebugging, debugging) {
    var global;
    if(globalOrDebugging === true) {
      debugging = true;
      global = {};
    } else {
      global = globalOrDebugging || {};
    }
    
    this.executionContext = {
      outer: null,
      variables: global,
    };
    
    this.executionContext.thisBinding = this.executionContext.variables;
    
    return this.program1(code, debugging)[1];
  };
  
  /**
   * &lt;tt>insignificant("sourceElements", "spaces")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.program1 = 
  interpreterMethodFactory.insignificant("sourceElements", "spaces");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#or|or} ("statementList")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.sourceElements = 
  interpreterMethodFactory.or("statementList");
  
  /**
   * &lt;tt>{@link InterpreterMethodFactory#methodFactory|methodFactory}
   * ("sourceElements")&lt;/tt>
   */
  JavaScriptInterpreter.prototype.deferredSourceElements = 
  interpreterMethodFactory.methodFactory("sourceElements");
  
};

JavaScriptInterpreter.hack();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-InterpreterObject.html">InterpreterObject</a></li><li><a href="external-ThisBinding.html">ThisBinding</a></li></ul><h3>Classes</h3><ul><li><a href="InterpreterMethodFactory.html">InterpreterMethodFactory</a></li><li><a href="InterpreterMethodFactory_MultiPropertyObject.html">MultiPropertyObject</a></li><li><a href="UsageExampleJavaScriptInterpreter.html">UsageExampleJavaScriptInterpreter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#butNotUnitTests">butNotUnitTests</a></li><li><a href="global.html#groupUnitTests">groupUnitTests</a></li><li><a href="global.html#insignificantUnitTests">insignificantUnitTests</a></li><li><a href="global.html#longestUnitTests">longestUnitTests</a></li><li><a href="global.html#methodFactoryUnitTests">methodFactoryUnitTests</a></li><li><a href="global.html#orUnitTests">orUnitTests</a></li><li><a href="global.html#plusUnitTests">plusUnitTests</a></li><li><a href="global.html#selectUnitTests">selectUnitTests</a></li><li><a href="global.html#starUnitTests">starUnitTests</a></li><li><a href="global.html#terminalUnitTests">terminalUnitTests</a></li><li><a href="global.html#wrapUnitTests">wrapUnitTests</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Nov 10 2017 18:34:58 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
